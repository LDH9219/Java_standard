## 1. 객체지향언어
### 1.1 객체지향언어
객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.' 라는 것이다.

### 1.2 객체지향언어
```
1. 코드의 재사용성이 높다
  새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
  코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
  제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오작동을 방지한다.
```

## 2. 클래스와 객체
### 2.1 클래스와 객체의 정의와 용도
```
클래스의 정의 : 클래스란 객체를 정의해 놓은 것이다.
클래스의 용도 : 클래스는 객체를 생성하는데 사용된다.
```

프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.
```
객체의 정의 : 실제로 존재하는 것. 사물 또는 개념
객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

유형의 객체 : 책상, 의자, 자동차, TV와 같은 사물
무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념
```

### 2.2 객체와 인스턴스
```
클래스 -(인스턴스화)-> 인스턴스(객체)
```

### 2.3 객체의 구성요소 - 속성과 기능
```
속성(property) : 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
기능(function) : 메서드(method), 함수(function), 행위(behavior)
```

### 2.4 인스턴스의 생성과 사용
```java
클래스명 변수명;
변수명 = new 클래스명();

Tv t; //Tv클래스 타입의 참조변수 t를 선언
t = new Tv(); //Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```
**인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.**

### 2.5 객체 배열
객체 역시 배열로 다루는 것이 가능하며, 이를 '객체 배열'이라고 한다.
```java
Tv tv1, tv2, tv3 -> Tv[] tvArr = new Tv[3];
```

### 2.6 클래스의 또 다른 정의
프로그래밍언어에서 데이터 처리를 위한 데이터 저장형태의 발전과정은 다음과 같다.
```
1. 변수 = 하나의 데이터를 저장할 수 있는 공간
2. 배열 = 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 = 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 = 데이터와 함수의 결합(구조체 + 함수)
```

## 3. 변수와 메서드
### 3.1 선언위치에 따른 변수의 종류
```java
class Variables{
  int iv; //인스턴스변수
  static int cv; //클래스변수(static 변수 ,공유변수) | 클래스 영역
  
  void method(){
    int iv = 0; //지역변수 | 메서드 영역
  }
}
```

|변수의 종류|선언위치|생성시기|
|:---------:|:--------:|:---------:|
|클래스변수<br>(class variable)|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴스변수<br>(instance variable)|클래스 영역|인스턴스가 생성되었을 때|
|지역변수<br>(local variable)|클래스 영역 이외의 영역<br>(메서드, 생성자, 초기화 블럭 내부)|변수 선언문이 수행되었을 때|

### 3.2 클래스 변수와 인스턴스 변수
```
인스턴스 변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만
클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.
```

### 3.3 메서드
#### 메서드를 사용하는 이유
1. 높은 재사용성
2. 중복된 코드의 제거
3. 프로그램의 구조화

### 3.4 메서드의 선언과 구현
메서드는 크게 두 부분 ```선언부(header)```와 ```구현부(body)```로 이루어져 있다.

#### **메서드 선언부**
메서드 선언부는 ```메서드의 이름```과 ```매개변수 선언``` 그리고 ```반환타입```으로 구성되어 있으며
메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보를 제공한다.

#### **매개변수 선언**
매개변수는 메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것이며, 필요한 값의 개수만큼 변수를 선언하며 각 변수 간의 구분은 쉼표','를 사용한다.
```java
int add(int x, int y) { ,,, } // OK.
int add(int x, y) { ,,, } // Error. 매개변수 y의 타입이 없다.
```

#### **반환타입**
메서드의 작업수행 결과(출력) 인 ```반환값(return value)```의 타입을 적는다.

#### **return문**
반환타입이 ```void```가 아닌 경우 ,구현부 {} 안에 ```return 반환값;```이 반드시 포함되어야 한다.
이 문장은 작업을 수행한 결과인 반환값을 호출한 메서드로 전달하는데, 이 값의 타입은 ```반환타입과 일치하거나 적어도 자동 형변환이 가능한 것```이어야 한다.

#### **지역변수**
메서드 내에 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드라면 같은 이름의 변수를 선언해도 된다.
이처럼 메서드 내에 선언된 변수를 ```지역변수```라고 한다.

### 3.5 메서드의 호출
```java
메서드이름(값1,값2,...); //메서드를 호출하는 방법

print99danAll(); //void print99danAll()을 호출
int result = add(3, 5); //int add(int x, int y)를 호출하고, 결과를 result 에 저장
```

### 3.6 return문
return 문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다.

### 3.7 JVM의 메모리 구조
응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받아 용도에 따라 여러 영역으로 나누어 관리한다.
<br>

![image](https://user-images.githubusercontent.com/62749021/183618068-5c9ebe8e-70a2-4976-ae23-177661505854.png)

#### 1. 메서드 영역
JVM은 사용되는 클래스의 클래스파일(.class)를 읽어 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.
클래스 변수도 이 영역에 함께 생성된다.

#### 2. 힙
프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
인스턴스 변수들이 생성되는 공간

#### 3. 호출스택
메서드의 작업에 필요한 메모리 공간 제공

**호출스택의 특징**
```
메서드가 호출되면 수행에 필요한 만큼의 메모리를 할당 받는다.
메서드가 작업을 마치면 할당되었던 메모리공간은 변환하고 스택에서 제거된다.
호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
```

### 3.8 기본형 매개변수와 참조형 매개변수
```
기본형 매개변수 = 변수의 값을 읽기만 할 수 있다.(read only)
참조형 매개변수 = 변수의 값을 읽고 변경할 수 있다.(read & write)
```

### 3.9 참조형 반환타입
```
반환타입이 '참조형' 이라는 것은
메서드가 '객체의 주소'를 반환한다는 것을 의미한다.
```

### 3.10 재귀호출
```java
void method(){
  method(); //재귀호출. 메서드 자신을 호출한다.
}
```

### 3.11 클래스 메서드(static 메서드)와 인스턴스 메서드
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

## 4. 오버로딩
### 4.1 오버로딩이란
한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 ```메서드 오버로딩``` 또는 ```오버로딩```이라 한다.

### 4.2 오버로딩의 조건
```
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
```
반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.

## 5. 생성자
### 5.1 생성자
인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드로 생성자 이름은 클래스 이름과 같고, 리턴값이 없다.

### 5.2 기본 생성자
클래스에 정의된 생성자가 하나도 없다면 컴파일러가 자동으로 기본 생성자를 생성해준다.

### 5.3 생성자에서 다른 생성자 호출하기 - this(), this
```
this
인스턴스 자신을 가리키는 참조변수, 인스턴스 주소 저장

this()
생성자, 같은 클래스의 다른 생성자 호출 시 사용
```

**생성자 간 호출이 가능한데 두 가지 조건을 만족시켜야 한다.**
```
1. 생성자의 이름으로 클래스이름 대신 this를 사용한다.
2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
```
```java
class Car {
    String color;
    String gearType;
    int door;
    
    Car() {
        this("white", "auto", 4);
    }

    Car(String color) {
        this(color, "auto", 4);
    }

    Car(String color, String gearType, int door) {
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}
```

## 6. 변수의 초기화
### 6.1 변수의 초기화
멤버변수(cv,iv)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.

#### 멤버변수의 초기화 방법
1. 명시적 초기화
2. 생성자
3. 초기화 블럭
  인스턴스 초기화 블럭 : 인스턴스변수 초기화 시 사용, 인스턴스 생성할 때마다 수행
  클래스 초기화 블럭 : 클래스변수 초기화 시 사용, 클래스가 메모리에 처음 로딩될 때 한번만 수행
  
### 6.2 멤버변수의 초기화 시기와 순서
```
클래스변수의 초기화 시점 = 클래스가 처음 로딩될 때 단 한번 초기화 된다.

인스턴스변수의 초기화 시점 = 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.

클래스변수의 초기화 순서
기본값 -> 명시적초기화 -> 클래스 초기화 블럭

인스턴스변수의 초기화 순서
기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자
```
